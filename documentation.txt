CSV Shell — Documentation
=========================

Purpose
-------
A tiny interactive console to work with CSV files:

- create lightweight “users” (data containers);
- attach CSV files to a user;
- list attachments;
- sort tables and create derived tables;
- define reusable sort keys (“compiled keys”);
- export user tables to disk (CSV / JSON);
- delete tables from memory or remove exported files from disk.

Startup, prompt, exit
--------------------
- On start, the shell creates a user named `sudo` and enters it.
- Prompt format:
  `(./<user>) >>>`  — inside a user (e.g., `(./sudo) >>>`)
  `(./) >>>`        — the root (no user selected)
- Exit commands: `quit` or `q`.

File system locations
---------------------
- **Export root**: `ROOT_PATH = "./root"`
  Saved files go to: `./root/<user>/<csv_name>.<ext>`
- **Default CSV** when path is omitted: `./homework_oop/repositories.csv`
- Avoid `~` in paths: existence is checked with `expanduser()`, but opening uses the original string.

Commands (current build)
------------------------

1) documentation
   Print this file (`./documentation.txt`).

   Example:
   ```
   (./sudo) >>> documentation
   ```

2) ls
   List the contents of the current context.

   - In root `(./)`: user names, one per line.
   - In a user `(./<user>)`: that user’s CSV names, one per line.
   - Prints nothing if empty.

   Examples:
   ```
   (./) >>> ls
   analysts
   sudo
   ```
   ```
   (./sudo) >>> ls
   iris
   ```

3) cd
   Change context. User names may contain spaces — everything after the first argument is treated as part of the name.

   Supported forms:
   - `cd /`          — go to root `(./)`.
   - `cd ..`         — go to root `(./)`.
   - `cd /<user>`    — jump to that user from anywhere.
   - `cd <user>`     — works **only** from root.
   - `cd ./<user>`   — works **only** from root (treated like `cd <user>`).
   - `cd .`          — no-op.

   Invalid prefix:
   - Inputs that begin with three dots (`...`) are rejected.

   Exact error messages:
   - `A user with that name does not exist.`
   - `Incorrect transition.`
   - `Incorrect path provided.`

4) add user [<name>]
   Create a new user (**only** in root).

   Behavior:
   - Without a name, a random SpongeBob-style name with a timestamp is generated.
   - Names must **not** start with `.` or `/`.
   - Duplicate names are rejected.

   Exact messages:
   - `Incorrect directory for creating a new user.`
   - `I'm sorry, but the username cannot begin with the characters . or /`
   - `This name is already exists`
   - `Add new user <name>`

   Examples:
   ```
   (./) >>> add user
   Add new user Patrick Star202510260101234567
   ```
   ```
   (./) >>> add user data team
   Add new user data team
   ```
   ```
   (./) >>> add user data team
   This name is already exists
   ```

5) add csv [<path>] [--name=<csv_name ...>]
   Attach a CSV file to the **current user** (not allowed in root).

   Path handling:
   - If `<path>` is omitted, the shell uses `./homework_oop/repositories.csv`.
   - The string is normalized internally; existence is checked with `expanduser()`;
     then the **original** string is used to open the file.
     Tip: avoid `~` in paths; use absolute or relative paths.

   Name handling:
   - If `--name=` is omitted: `default_1`, `default_2`, ...
   - Everything after `--name=` is part of the name (spaces allowed).

   Tokenization tip:
   - The path is consumed until the first token that starts with `--name=`.

   Exact messages:
   - `I'm sorry, but add csv cannot be used in the root directory`
   - `Incorrect path provided.`
   - `This name is already exists`
   - `Add new csv file <csv_name> to the user <user>`

   Examples:
   ```
   (./sudo) >>> add csv ./datasets/iris.csv --name=iris
   Add new csv file iris to the user sudo
   ```
   ```
   (./sudo) >>> add csv
   Add new csv file default_1 to the user sudo
   ```

6) key create <key_name> / key list
   6.1) Create a reusable key function for sorting (in the current user).
        After this command, the shell prompts you to type the expression line.

   Security: the function is compiled with a restricted `SAFE_BUILTINS` set.

   Flow:
   ```
   (./user) >>> key create score_key
   def score_key(x):
       return <TYPE YOUR EXPRESSION HERE AND PRESS ENTER>
   ```

   Examples:
   ```
   (./sudo) >>> key create abs_key
   def abs_key(x):
       return abs(x)
   ```

   Errors:
   - `Key compile error: <python-exception-text>`
   - `Invalid name of the key >:(` (if key_name is not a valid identifier)

   6.2) List keys:
   ```
   (./sudo) >>> key list
   def abs_key(x):
       return abs(x)
   ```

7) sort <csv_name> | --column <name|index> [--using <key>] [--type <int|float|str>] --out <new_csv_name>
   Sort the given CSV (in memory) by the specified column and create a **new** CSV stored under `--out`.

   Arguments:
   - `--column`  (**required**)  — column index (0-based) **or** column name.
   - `--out`     (**required**)  — name for the new CSV (must not already exist).
   - `--type`    (optional)      — cast the column values before sorting: `int | float | str`.
   - `--using`   (optional)      — name of a previously created key (see `key create`).
                                   The key is applied to the (possibly cast) value.

   Behavior:
   - Full rows are reordered by the column; row associations are preserved.
   - The result lives in memory only — use `save` to persist to disk.

   Success message:
   - `Created CSV '<new_csv_name>'`

   Typical errors:
   - `CSV '<name>' not found.`
   - `Sort error: Missing required --column`
   - `Sort error: Missing required --out <new_csv_name>`
   - `Sort error: Unknown type: <something>`
   - `Sort error: No such key: <key_name>`
   - `Sort error: CSV '<new_name>' already exists`
   - `Sort failed.`

   Examples:
   ```
   # Sort by numeric column (cast to int)
   (./sudo) >>> sort repos | --column Forks --type int --out repos_by_forks
   Created CSV 'repos_by_forks'
   ```
   ```
   # Sort by index with custom key
   (./sudo) >>> key create negate
   def negate(x):
       return -int(x)
   (./sudo) >>> sort repos | --column 2 --using negate --out repos_desc_by_col2
   Created CSV 'repos_desc_by_col2'
   ```
   ```
   # Case-insensitive sort by a text column
   (./sudo) >>> key create lower
   def lower(x):
       return x.lower()
   (./sudo) >>> sort contacts | --column Name --using lower --out contacts_by_name_ci
   Created CSV 'contacts_by_name_ci'
   ```

8) save [ . | --names=<csv1,csv2,...> ] [--format=.csv|.json]
   Export the current user’s CSVs to disk under `./root/<user>/`.

   Context A — inside a user `(./<user>)`
   - **Save all CSVs** (default format `.csv`):
     ```
     (./alice) >>> save
     Successful preservation
     ```
     Shorthand:
     ```
     (./alice) >>> save .
     Successful preservation
     ```

   - **Save as JSON**:
     ```
     (./alice) >>> save --format=.json
     Successful preservation
     ```
     (JSON orientation is `"records"`.)

   - **Save only selected CSVs**:
     ```
     (./alice) >>> save --names=iris,metrics --format=.csv
     Successful preservation
     ```

   Context B — in root `(./)`
   - **Save all CSVs of all users** (default `.csv`):
     ```
     (./) >>> save all
     Successful preservation
     ```
   - **As JSON**:
     ```
     (./) >>> save all --format=.json
     Successful preservation
     ```

   Notes:
   - Supported formats: `.csv`, `.json` — anything else ⇒
     `I'm sorry, but I cannot work with the .<ext> format`
   - `--names=` expects a **comma-separated** list (no spaces inside tokens).
   - If a listed name doesn’t exist ⇒ `Name <csv_name> doesn't exist`

   Output files:
   - `./root/<user>/<csv_name>.csv`
   - `./root/<user>/<csv_name>.json`

9) delete — updated & detailed
------------------------------
Delete CSVs from **memory** (not from disk).

### Context A — inside a user `(./<user>)`
- **Delete all CSVs from memory (current user):**
  ```
  (./alice) >>> delete
  Successful deletion
  ```
  or
  ```
  (./alice) >>> delete .
  Successful deletion
  ```

- **Delete selected CSVs by name:**
  ```
  (./alice) >>> delete --names=iris,metrics
  Successful deletion
  ```
  - `--names` takes a **comma-separated** list without spaces.
  - If any name does not exist, you’ll get: `Name <csv_name> doesn't exist`.

- **Optional `--format` validation (ignored functionally):**
  You **may** add `--format=.csv` or `--format=.json`. For `delete`, this flag is **validated but ignored** (it does **not** change behavior).
  Unsupported extensions produce:
  ```
  I'm sorry, but I cannot work with the .<ext> format
  ```

**Important: argument order inside a user**
Name parsing **stops** at the first `--format=` token. Therefore:
```
(./alice) >>> delete --names=iris --format=.csv   # OK: deletes only 'iris' from memory
(./alice) >>> delete --format=.csv --names=iris   # Caution: deletes ALL CSVs from memory
```
In the second line, `--names` is ignored for parsing (because name collection stops at `--format`), resulting in **all** CSVs being targeted.

### Context B — in root `(./)`
- **Delete everything from memory and clear the user list:**
  ```
  (./) >>> delete
  Successful deletion
  ```
  or
  ```
  (./) >>> delete --all
  Successful deletion
  ```
  This removes all users from memory and all their in-memory CSVs.
  **Note:** the legacy `delete all` (without dashes) is **not** recognized and will be treated as a username.

- **Delete a specific user from memory (and their in-memory CSVs):**
  ```
  (./) >>> delete data team
  Successful deletion
  ```
  Everything after `delete` is treated as the user name (spaces allowed).
  **Disk files are not touched** — use `rdelete` for exported files.

10) rdelete — updated & detailed
--------------------------------
Delete **exported files** from disk under `./root`.

### Context A — inside a user `(./<user>)`
This mode removes files under `./root/<user>/` matching the chosen extension:

- **Remove all exported `.csv` files** for the current user (default):
  ```
  (./alice) >>> rdelete
  Successful rdeletion
  ```
  This is equivalent to:
  ```
  (./alice) >>> rdelete --format=.csv
  Successful rdeletion
  ```

- **Remove all exported `.json` files** for the current user:
  ```
  (./alice) >>> rdelete --format=.json
  Successful rdeletion
  ```

- **Remove selected files by CSV name (must match the saved extension):**
  ```
  (./alice) >>> rdelete --names=iris,metrics --format=.json
  Successful rdeletion
  ```
  **Important:**
  - You **must** match the extension you saved earlier.
    If you saved JSONs and call `rdelete` without `--format=.json`, the `.json` files will remain.
  - Missing files are silently ignored.

- **Unsupported formats** produce:
  ```
  I'm sorry, but I cannot work with the .<ext> format
  ```

**Important: argument order inside a user**
Name parsing **stops** at the first `--format=` token. Therefore:
```
(./alice) >>> rdelete --names=iris --format=.csv   # OK: removes only iris.csv
(./alice) >>> rdelete --format=.csv --names=iris   # Caution: removes ALL *.csv for the user
```

### Context B — in root `(./)`
Root mode focuses on directories, not individual filenames:

- **Remove the entire export directory for all users:**
  ```
  (./) >>> rdelete
  Successful rdeletion
  ```
  or
  ```
  (./) >>> rdelete --all
  Successful rdeletion
  ```
  This deletes the **whole** `./root/` directory recursively (all users, all files, all formats).

- **Remove only one user’s export folder:**
  ```
  (./) >>> rdelete data team
  Successful deletion
  ```
  This deletes `./root/data team/` recursively.
  **Note message:** in this branch the success text is `Successful deletion`.

**Not supported in root:**
- `rdelete --names=...` is **not** supported at root level.
- `rdelete all` (without dashes) is **not** recognized; use `rdelete` or `rdelete --all`.

Messages & errors (reference)
-----------------------------
- `I'm sorry, I couldn't understand the command.`
- `A user with that name does not exist.`
- `Incorrect transition.`
- `Incorrect path provided.`
- `Incorrect directory for creating a new user.`
- `I'm sorry, but the username cannot begin with the characters . or /`
- `I'm sorry, but add csv cannot be used in the root directory`
- `This name is already exists`
- `Name <csv_name> doesn't exist`
- `I'm sorry, but I cannot work with the .<ext> format`
- `Successful preservation`
- `Successful deletion`
- `Successful rdeletion`
- `Add new user <name>`
- `Add new csv file <csv_name> to the user <user>`
- `Created CSV '<new_csv_name>'`

Data model (internal)
---------------------

Root
- `names: dict[str, User]` — all users by name.
- `clear()` — removes all users.

User
- `username: str`
- `all_csv: dict[str, ReadCSV]` — tables by name.
- `sort_keys: dict[str, Callable[[Any], Any]]` — compiled key functions.
- `key_name_to_source: dict[str, str]` — source snippet for listing.
- `add_csv(path, name) -> str | NAME_EXISTS | None`
- `all_csv_names() -> list[str] | None`
- `get_csv(name) -> ReadCSV | None`
- `csv_file_exists(name) -> bool`
- `del_csv(name) -> None`
- `compileNamedKey(name, expression) -> Callable` (secured by `SAFE_BUILTINS`)

ReadCSV
- Header: first row are column names.
- `translate: dict[str, int]` — column name → index.
- `re_translate: Vector` — reverse mapping (index → name).
- `table: Vector` — each row is a NumPy row (`np.array(object)`).
- Automatic per-column casting on load:
  tries `int → float → bool ("true"/"false") → list/tuple via ast.literal_eval`; otherwise leaves strings.

Vector (storage primitive)
- Dynamic array backed by NumPy.
- `append`, `copy`, `deepcopy`; integer/slice indexing; 2-D reads like `v[:, j]`; iteration.
- Negative integer index supported via modulo by size.

Programmatic helpers (in code)
------------------------------
- `python_sort_column(csv: ReadCSV, column_number: int | str, needed_type: int|float|str|None = None, key: Callable[[Any], Any] | None = None) -> ReadCSV | None`
  Sorts rows by the chosen column (ascending) and returns a full table copy sorted by that column.
  If `needed_type` is provided, it casts the column values before key/compare.
  If `key` is provided, it transforms the value before comparison.
  Used by the `sort` command.

- `medianByColumn(csv: ReadCSV, column: int | str) -> float`
  Median of the chosen column (ascending order); if even length, average of two middles.

- `getNBestByColumn(csv: ReadCSV, column: int | str, number: int) -> ReadCSV`
  Take last `number` rows from ascending-sorted-by-column (i.e., top-k largest); returns a table.

- `save_as_csv(read_csv: ReadCSV, path: str, delimiter: str = ",", write_header: bool = True)`
- `save_as_json(read_csv: ReadCSV, path: str, orient: str = "records", ensure_ascii: bool = False, indent: int | None = 2)`
  JSON orients supported in code: `"records"` (default), `"split"`, `"jsonl"`.
  CLI always uses `"records"`.

Examples (end-to-end)
---------------------
```
# Attach and list
(./sudo) >>> add csv ./datasets/iris.csv --name=iris
Add new csv file iris to the user sudo
(./sudo) >>> ls
iris
```
```
# Define and view keys
(./sudo) >>> key create lower
def lower(x):
    return x.lower()
(./sudo) >>> key list
def lower(x):
    return x.lower()
```
```
# Sort by a text column case-insensitively
(./sudo) >>> sort iris | --column species --using lower --out iris_by_species
Created CSV 'iris_by_species'
(./sudo) >>> ls
iris
iris_by_species
```
```
# Save everything to CSV files
(./sudo) >>> save
Successful preservation
# → ./root/sudo/iris.csv
# → ./root/sudo/iris_by_species.csv
```
```
# Delete a derived table from memory (file on disk stays)
(./sudo) >>> delete --names=iris_by_species
Successful deletion
(./sudo) >>> ls
iris
```
```
# Remove exported CSVs for this user (disk cleanup)
(./sudo) >>> rdelete --format=.csv
Successful rdeletion
# → deletes ./root/sudo/*.csv
```
```
# From root: clean everything (memory and disk)
(./sudo) >>> cd /
(./) >>> delete
Successful deletion
(./) >>> rdelete
Successful rdeletion
```
